---
pageTitle: Select API
title: Select
---

import { ScopeableLayout } from '../../components/layout';
import {
  Select,
  SelectStateChangeTypes,
  Alert,
  I18nContext,
  defaultI18n,
  Card,
  CardBody,
} from 'react-magma-dom';
import { SimplePropsTable } from '../../components/props-table';
import { useSelect } from 'downshift';
import { Link } from 'gatsby';
import { v4 as uuid } from 'uuid';
import DocsHeading from '../../components/docs-heading';

<DocsHeading to="/design/select/" type="design">
  Selects
</DocsHeading>

## Basic Usage

Select components are used for collecting user provided information from a list of options.

For combobox/autocomplete functionality, please see the <Link to="/api/combobox">Combobox component</Link>.

If you are migrating from the <Link to="/api/legacy-select">Legacy Select</Link>, please see the <Link to="/select-migration">Select Migration docs</Link> for details on how to make the transition.

By default when passing in a `selectedItem` it will be checked to make sure it is in your `items` array. The check will use the
`itemToString` function on both the `selectedItem` and each `item` in the array. The default `itemToString` function
is able to be used for `items` that are either `strings` or an object with the shape `{item: string; label: string;}`.
If you are using a custom items format see the [Custom Items example](/api/select/#custom_items).

```.jsx
  () => {
    const [selectedItem, updateSelectedItem] = React.useState('');

    function onSelectedItemChange(changes) {
      updateSelectedItem(changes.selectedItem);
    }

    return (
      <>
        <Select
          id="basicSelectId"
          name="basic"
          labelText="Basic"
          items={[
            { label: 'Red', value: 'red' },
            { label: 'Blue', value: 'blue' },
            { label: 'Green', value: 'green' }
          ]}
          selectedItem={selectedItem}
          onSelectedItemChange={onSelectedItemChange}
        />

        <Select
          id="badSelectedItemId"
          name="badSelectedItem"
          labelText="Bad Selected Item"
          items={[
            { label: 'Red', value: 'red' },
            { label: 'Blue', value: 'blue' },
            { label: 'Green', value: 'green' }
          ]}
          selectedItem={{ label: 'Purple', value: 'purple' }}
        />
      </>
    )
  }
```

## Initial State

Set initial state using the `initialSelectedItem`, `initialSelectedItems`, and `initialHighlightedIndex` props.

<Alert variant="info">
  When using any of the <code class="inverse">initial*</code> props be aware
  that passing in the controlled version of that prop will overwrite the initial
  version.
  <br />
  <br />
  <strong>Ex: </strong>
  <code class="inverse">selectedItem</code> takes precedence over{' '}
  <code class="inverse">initialSelectedItem</code>
</Alert>

```.jsx
  () => {
    return (
      <>
        <Select
          id="initialSelectedByItemSelectId"
          name="initialSelectedByItem"
          labelText="Initial Selected By Item"
          items={[
            { label: 'Red', value: 'red' },
            { label: 'Blue', value: 'blue' },
            { label: 'Green', value: 'green' }
          ]}
          initialSelectedItem={{ label: 'Green', value: 'green' }}
        />

        <Select
          id="initialHighlightedIndexSelectId"
          name="initialHighlightedIndex"
          labelText="Initial Highlighted Index"
          items={[
            { label: 'Red', value: 'red' },
            { label: 'Blue', value: 'blue' },
            { label: 'Green', value: 'green' }
          ]}
          initialHighlightedIndex={1}
        />
      </>
    )
  }
```

## Specific State Changes

You can track specific changes made to the internal state of the `select` using the following functions: `onHighlightedIndexChange`,
`onIsOpenChange`, and `onSelectedItemChange`. Each of these functions will have a `changes` object as a parameter that
includes the changes made to the corresponding state from each action.

```.jsx
  () => {
    const [highlightedIndexChangeCount, updateHighlightedIndexChangeCount] = React.useState(0);
    const [isOpenChangeCount, updateIsOpenChangeCount] = React.useState(0);
    const [selectedItem, updateSelectedItem] = React.useState(undefined);

    function onHighlightedIndexChange(changes) {
      updateHighlightedIndexChangeCount(highlightedIndexChangeCount + 1);
    }

    function onIsOpenChange(changes) {
      updateIsOpenChangeCount(isOpenChangeCount + 1)
    }

    function onSelectedItemChange(changes) {
      updateSelectedItem(changes.selectedItem);
    }

    return (
      <>
        <strong>Selected Item: </strong><pre>{JSON.stringify(selectedItem, null, 2)}</pre>
        <p><strong>Highlighted Index Change Count: </strong>{highlightedIndexChangeCount}</p>
        <p><strong>Is Open Change Count: </strong>{isOpenChangeCount}</p>

        <Select
          id="stateChangesId"
          name="stateChanges"
          labelText="State Changes"
          items={[
            { label: 'Red', value: 'red' },
            { label: 'Blue', value: 'blue' },
            { label: 'Green', value: 'green' }
          ]}
          onHighlightedIndexChange={onHighlightedIndexChange}
          onIsOpenChange={onIsOpenChange}
          onSelectedItemChange={onSelectedItemChange}
        />
      </>
    )
  }
```

## Generic State Change

<Alert variant="warning">
  Using <code>onStateChange</code> and controlling every piece of{' '}
  <code>state</code> will result in losing most of the functionality that has
  been built in to this component. Only use this feature as a last resort.
</Alert>

`onStateChange` is called when any internal state is changed. Therefore, it is best used when using the
`select` in a controlled state.

The `onStateChange` function passes a `changes` object that includes properties that have changed since the
last state change. The `changes` object also includes a `type` property that describes the action taken
to change the state. You can see the full list of the types in the [`stateChangeTypes`](/api/select/#state_change_types) section.

```.jsx
  () => {
    const [changes, updateChanges] = React.useState({});
    const [highlightedIndex, updateHighlightedIndex] = React.useState(-1);
    const [isOpen, updateIsOpen] = React.useState(false);
    const [selectedItem, updateSelectedItem] = React.useState('');

    function onStateChange(newChanges) {
      const { type } = newChanges
      updateChanges(newChanges)

      switch(type) {
        case SelectStateChangeTypes.ToggleButtonClick:
          updateIsOpen(!isOpen)
        case SelectStateChangeTypes.ToggleButtonKeyDownArrowDown:
          updateIsOpen(newChanges.isOpen)
          updateHighlightedIndex(newChanges.highlightedIndex)
        case SelectStateChangeTypes.ItemMouseMove:
        case SelectStateChangeTypes.FunctionSetHighlightedIndex:
        case SelectStateChangeTypes.MenuKeyDownArrowDown:
        case SelectStateChangeTypes.MenuKeyDownArrowUp:
          updateHighlightedIndex(newChanges.highlightedIndex)
        case SelectStateChangeTypes.MenuKeyDownEscape:
        case SelectStateChangeTypes.MenuBlur:
          updateIsOpen(false)
          updateHighlightedIndex(newChanges.highlightedIndex)
        case SelectStateChangeTypes.ItemClick:
          updateHighlightedIndex(newChanges.highlightedIndex)
          updateIsOpen(newChanges.isOpen)
          updateSelectedItem(newChanges.selectedItem)
        default:
          break;
      }
    }

    return (
      <>
        <pre>{JSON.stringify(changes, null, 2)}</pre>

        <Select
          id="stateChangesId"
          name="stateChanges"
          labelText="State Changes"
          items={[
            { label: 'Red', value: 'red' },
            { label: 'Blue', value: 'blue' },
            { label: 'Green', value: 'green' }
          ]}
          onStateChange={onStateChange}
          highlightedIndex={highlightedIndex}
          isOpen={isOpen}
          selectedItem={selectedItem}
        />
      </>
    )
  }
```

## Controlled

If you wish to control the state rather than having it handled internally you can use the control props
provided. These props are `isOpen`, `selectedItem`, and `highlightedIndex`. If you are using these control props
you will have to use the handlers mentioned above in the <Link to="/api/select/#state_changes">State Changes</Link> section.

```.jsx
  () => {
    const [highlightedIndex, updateHighlightedIndex] = React.useState(0);
    const [isOpen, updateIsOpen] = React.useState(false);
    const [selectedItem, updateSelectedItem] = React.useState('');

    function onHighlightedIndexChange(changes) {
      updateHighlightedIndex(changes.highlightedIndex);
    }

    function onIsOpenChange(changes) {
      updateIsOpen(changes.isOpen)
    }

    function onSelectedItemChange(changes) {
      updateSelectedItem(changes.selectedItem);
    }

    return (
      <>
        <strong>Selected Item: </strong><pre>{JSON.stringify(selectedItem, null, 2)}</pre>
        <p><strong>Highlighted Index: </strong>{highlightedIndex}</p>
        <p><strong>Is Open: </strong>{isOpen.toString()}</p>

        <Select
          id="controlledId"
          name="controlled"
          labelText="Controlled"
          items={[
            { label: 'Red', value: 'red' },
            { label: 'Blue', value: 'blue' },
            { label: 'Green', value: 'green' }
          ]}
          isOpen={isOpen}
          highlightedIndex={highlightedIndex}
          selectedItem={selectedItem}
          onHighlightedIndexChange={onHighlightedIndexChange}
          onIsOpenChange={onIsOpenChange}
          onSelectedItemChange={onSelectedItemChange}
        />
      </>
    )
  }
```

## Disabled

```.jsx
  <Select
    id="disabledSelectId"
    disabled
    name="disabled"
    labelText="Disabled"
    items={[
      { label: 'Red', value: 'red' },
      { label: 'Blue', value: 'blue' },
      { label: 'Green', value: 'green' }
    ]}
  />
```

## Clearable

The optional `isClearable` prop allows the user to clear the field once a selection has been made.

When using the `isClearable` prop you can choose a default selected item to be set once the `select` is cleared
using the `defaultSelectedItem` prop.

```.jsx
  <>
    <Select
      id="clearableSelectId"
      name="clearable"
      labelText="Clearable"
      items={[
        { label: 'Red', value: 'red' },
        { label: 'Blue', value: 'blue' },
        { label: 'Green', value: 'green' }
      ]}
      initialSelectedItem={{ label: 'Green', value: 'green' }}
      isClearable
    />

    <Select
      id="clearableWithDefaultsId"
      name="clearableWithDefaults"
      labelText="Clearable With Defaults"
      items={[
        { label: 'Red', value: 'red' },
        { label: 'Blue', value: 'blue' },
        { label: 'Green', value: 'green' }
      ]}
      isClearable
      defaultSelectedItem={{ label: 'Blue', value: 'blue' }}
    />
  </>
```

## Error Message

If a select has an `errorMessage`, the select will be styled to highlight it's error state and the error message will appear below the field.
If an error message is present, it will replace the helper text. Can be a node or a string.

```.jsx
  <>
    <Select
      id="errorMessage"
      name="error"
      labelText="Error Message"
      items={[
        { label: 'Red', value: 'red' },
        { label: 'Blue', value: 'blue' },
        { label: 'Green', value: 'green' }
      ]}
      errorMessage="Please select a color"
    />
  </>
```

## Helper Message

The `helperMessage` appears underneath the select field. It will not appear if an error message is present. Can be a node or a string.

```.jsx
  <>
    <Select
      id="helperMessage"
      name="helper"
      labelText="Helper Message"
      items={[
        { label: 'Red', value: 'red' },
        { label: 'Blue', value: 'blue' },
        { label: 'Green', value: 'green' }
      ]}
      helperMessage="Helper text goes here"
    />
  </>
```

## Accessibility

The `getA11yStatusMessage` prop is a passed in function that allows for customization of the screen-reader accessible message whenever the following props
are changed: `items`, `highlightedIndex`, `inputValue` or `isOpen`.

The `getA11ySelectionMessage` prop is a passed in function that allows for customization of the screen-reader accessible message
whenever an item has been selected.

For both the `getA11yStatusMessage` and `getA11ySelectionMessage` functions there is an
[object passed with internal state data](https://github.com/downshift-js/downshift/tree/master/src/hooks/useSelect#geta11yselectionmessage).

```.jsx
  <>
    <Select
      id="newA11yStatusMessageId"
      name="newA11yStatusMessage"
      labelText="New Accessibility Status Message"
      items={[
        { label: 'Red', value: 'red' },
        { label: 'Blue', value: 'blue' },
        { label: 'Green', value: 'green' }
      ]}
      getA11yStatusMessage={({highlightedItem}) => `custom message saying that ${highlightedItem} is highlighted`}
      getA11ySelectionMessage={({selectedItem}) => `custom message saying that ${selectedItem} is now selected`}
    />
  </>
```

## Multi Select

```.jsx
  () => {
    const [selectedItems, updateSelectedItems] = React.useState([]);

    function handleSelectedItemsChange(changes) {
      updateSelectedItems(changes.selectedItems);
    }

    function handleRemoveSelectedItem(removedItem) {
      updateSelectedItems(
        selectedItems.filter(item => item !== removedItem)
      )
    }

    return <>
      <Select
        id="multiSelectId"
        isMulti
        name="multiSelect"
        labelText="Multi Select"
        items={[
          {label: 'Red', value: 'red'},
          {label: 'Blue', value: 'blue'},
          {label: 'Green', value: 'green'},
          {label: 'Orange', value: 'orange'},
          {label: 'Aqua', value: 'aqua'},
          {label: 'Gold', value: 'gold'},
          {label: 'Periwinkle', value: 'periwinkle'},
          {label: 'Lavender', value: 'lavender'},
          {label: 'Marigold', value: 'marigold'},
          {label: 'Yellow', value: 'yellow'},
          {label: 'Purple', value: 'purple'},
          {label: 'Dusty Rose', value: 'dusty_rose'},
          {label: 'Burnt Sienna', value: 'burnt_sienna'}
        ]}
        initialSelectedItems={[
          {label: 'Red', value: 'red'},
          {label: 'Blue', value: 'blue'},
          {label: 'Blah', value: 'blah'}
        ]}
      />

      <Select
        id="multiSelectControlledId"
        isMulti
        name="multiSelectControlled"
        labelText="Multi Select Controlled"
        items={[
          {label: 'Red', value: 'red'},
          {label: 'Blue', value: 'blue'},
          {label: 'Green', value: 'green'},
          {label: 'Orange', value: 'orange'},
          {label: 'Aqua', value: 'aqua'},
          {label: 'Gold', value: 'gold'},
          {label: 'Periwinkle', value: 'periwinkle'},
          {label: 'Lavender', value: 'lavender'},
          {label: 'Marigold', value: 'marigold'},
          {label: 'Yellow', value: 'yellow'},
          {label: 'Purple', value: 'purple'},
          {label: 'Dusty Rose', value: 'dusty_rose'},
          {label: 'Burnt Sienna', value: 'burnt_sienna'}
        ]}
        selectedItems={selectedItems}
        onSelectedItemsChange={handleSelectedItemsChange}
        onRemoveSelectedItem={handleRemoveSelectedItem}
      />
    </>
  }
```

## Events

```.jsx
  () => {
    const [currentSelectEvent, updateCurrentSelectEvent] = React.useState(undefined);

    function handleSelectBlur(event) {
      updateCurrentSelectEvent('Blur')
    }

    function handleSelectFocus(event) {
      updateCurrentSelectEvent('Focus')
    }

    function handleSelectKeyPress(event) {
      updateCurrentSelectEvent('KeyPress')
    }

    return (
      <>
        <p><strong>{currentSelectEvent || 'No'} event was triggered</strong></p>

        <Select
          id="selectFocusEventId"
          name="selectFocusEvent"
          labelText="Select Focus Events"
          items={[
            { label: 'Red', value: 'red' },
            { label: 'Blue', value: 'blue' },
            { label: 'Green', value: 'green' }
          ]}
          onBlur={handleSelectBlur}
          onFocus={handleSelectFocus}
          onKeyPress={handleSelectKeyPress}
        />
      </>
    )
  }
```

## Inverse

```.jsx
  () => {
    const [selectedItem, updateSelectedItem] = React.useState('');

    function onSelectedItemChange(changes) {
      updateSelectedItem(changes.selectedItem);
    }


    const [selectedItems, updateSelectedItems] = React.useState([]);

    function handleSelectedItemsChange(changes) {
      updateSelectedItems(changes.selectedItems);
    }

    function handleRemoveSelectedItem(removedItem) {
      updateSelectedItems(
        selectedItems.filter(item => item !== removedItem)
      )
    }

    return (
      <Card isInverse>
        <CardBody>
          <Select
            id="basicSelectInverseId"
            isInverse
            name="basic"
            labelText="Basic"
            items={[
              { label: 'Red', value: 'red' },
              { label: 'Blue', value: 'blue' },
              { label: 'Green', value: 'green' }
            ]}
            selectedItem={selectedItem}
            onSelectedItemChange={onSelectedItemChange}
          />

          <Select
            id="multiSelectInverseId"
            isInverse
            isMulti
            name="multiSelect"
            labelText="Multi Select"
            items={[
              { label: 'Red', value: 'red' },
              { label: 'Blue', value: 'blue' },
              { label: 'Green', value: 'green' }
            ]}
          />
        </CardBody>
      </Card>
    )
  }
```

## Custom Styles

Custom styles can be passed into the Select component. The `containerStyle` property will apply to the container.
Additional `labelStyle`, `inputStyle` and `messageStyle` properties are available to style the respective elements.
Please use discretion when adding custom styles.

```.jsx
  () => {
    const [selectedItem, updateSelectedItem] = React.useState('');

    function onSelectedItemChange(changes) {
      updateSelectedItem(changes.selectedItem);
    }

    return <>
      <Select
        containerStyle={{ marginBottom: '32px'}}
        helperMessage="Helper message"
        inputStyle={{ border: '2px dotted green', width: '200px'}}
        items={['Red', 'Blue', 'Green']}
        labelStyle={{ fontStyle: 'italic' }}
        labelText="Basic with Custom Styles"
        messageStyle={{ border: '1px solid blue' }}
        selectedItem={selectedItem}
        onSelectedItemChange={onSelectedItemChange}
      />

      <Select
        containerStyle={{ marginBottom: '32px'}}
        helperMessage="Helper message"
        inputStyle={{ border: '2px dotted green', width: '200px'}}
        isMulti
        items={['Red', 'Blue', 'Green']}
        labelStyle={{ fontStyle: 'italic' }}
        labelText="Multi with Custom Styles"
        messageStyle={{ border: '1px solid blue' }}
        selectedItem={selectedItem}
        onSelectedItemChange={onSelectedItemChange}
      />
    </>
  }
```

## Internationalization

Some of the internationalization overrides use placeholders to insert selected values in to the message.
Placeholders are specific keywords surrounded by curly braces.

- `{labelText}` will be replaced with the comboboxes `labelText`.
- `{selectedItem}` will be replaced by the current `itemToString` representation of the `selectedItem` of the `select`.

<Link to="/api/internationalization">
  Full example of internationalization override options
</Link>

```.jsx
  <I18nContext.Provider value={{
    ...defaultI18n,
    select: {
      placeholder: 'Custom Select Placeholder...',
      clearIndicatorAriaLabel: 'Click to reset selection for {labelText}. {selectedItem} is currently selected'
    },
    multiSelect: {
      selectedItemButtonAriaLabel: 'Click to reset the selected item {selectedItem}'
    }
  }}>
    <Select
      labelText="Internationalization"
      items={[
        { label: 'Red', value: 'red' },
        { label: 'Blue', value: 'blue' },
        { label: 'Green', value: 'green' }
      ]}
      initialSelectedItem={{ label: 'Red', value: 'red' }}
      isClearable
    />

    <Select
      labelText="Multi Internationalization"
      isMulti
      items={[
        { label: 'Red', value: 'red' },
        { label: 'Blue', value: 'blue' },
        { label: 'Green', value: 'green' }
      ]}
      initialSelectedItems={[{ label: 'Red', value: 'red' }]}
    />
  </I18nContext.Provider>
```

## Custom Items

By default each component accepts an array of `items` with either a `string` or an `object` with the shape `{item: string; label: string;}`
for each `item`. If you need to pass in a custom shape for your `items` you can pass in an additional prop named `itemToString`
which is a function that returns the string representation of your `item` which will be applied as the label.

<Alert variant="warning">
  <strong>WARNING</strong> Your function must include a <code>null</code> check.
</Alert>

If you are using a custom shape for your `items` in a `typescript` project refer to our example of [using your
custom `type`](/api/select#custom_items_typescript).

```.jsx
  () => {
    function itemToString(item) {
      return item ? `${item.representation} (${item.hex})` : ''
    }

    return (
      <>
        <Select
          id="itemToStringId"
          name="itemToString"
          labelText="Item to String"
          items={[{
            id: 1,
            actual: 'red',
            representation: 'Red',
            hex: '#FF0000'
          }, {
            id: 2,
            actual: 'blue',
            representation: 'Blue',
            hex: '#0000FF'
          }, {
            id: 3,
            actual: 'green',
            representation: 'Green',
            hex: '#008000'
          }]}
          itemToString={itemToString}
        />
      </>
    )
  }
```

## Custom Items Typescript

When using a custom shape for your `items` in a `typescript` project you will need to provide the `Select`
element with the shape of the `items` you are passing in.

```
  interface CustomSelectItem {
    id: number;
    actual: string;
    representation: string;
    hex?: string;
  }

  () => {
    const customItems: CustomSelectItem[] = [
      {
        id: 1,
        actual: "red",
        representation: "Red",
        hex: "#FF0000",
      },
      {
        id: 2,
        actual: "blue",
        representation: "Blue",
        hex: "#0000FF",
      },
      {
        id: 3,
        actual: "green",
        representation: "Green",
        hex: "#008000",
      },
    ];

    function itemToString(item: CustomSelectItem) {
      return item ? `${item.representation} (${item.hex})` : ''
    }

    return (
      <>
        <Select<CustomSelectItem>
          id="customItemToStringTypescriptId"
          labelText="Custom Items with Typescript"
          items={customItems}
          itemToString={itemToString}
        />
      </>
    )
  }
```

## Custom Components

Out of the box, the `Select` component uses React Magma-styled iconography for the button used to clear the selection and the caret for the dropdown.
However, these can be overridden by providing custom components to the `components` prop, in an object containing a `ClearIndicator` and a `DropdownIndicator`.

```.jsx
  <Select
    id="customComponentsId"
    name="customComponents"
    labelText="Custom Components"
    items={[
      { label: 'Red', value: 'red' },
      { label: 'Blue', value: 'blue' },
      { label: 'Green', value: 'green' }
    ]}
    initialSelectedItem={{ label: 'Green', value: 'green' }}
    isClearable
    components={{
      ClearIndicator: (props) => <button onClick={props.onClick}>Clear</button>,
      DropdownIndicator: () => <span style={{ border: '1px solid'}}>Dropdown</span>
    }}
  />
```

## State Change Types

The `type` property in the `changes` object that is returned from the `onStateChange` function
corresponds to a `stateChangeTypes` property. The list of all the possible types for a `select` or a
`multi-select` are listed below.

<Alert variant="info">
  In the development environment these types equate to strings
  <br />
  (eg:{' '}
  <code class="inverse">
    ComboboxStateChangeTypes.InputKeyDownArrowDown =
    '__input_keydown_arrow_down__'
  </code>
  ). However, in the production environment the types equate to numbers
  <br />
  (eg: <code class="inverse">
    ComboboxStateChangeTypes.InputKeyDownArrowDown = 0
  </code>
  ).
</Alert>

### Select

- `SelectStateChangeTypes.MenuKeyDownArrowDown`
- `SelectStateChangeTypes.MenuKeyDownArrowUp`
- `SelectStateChangeTypes.MenuKeyDownEscape`
- `SelectStateChangeTypes.MenuKeyDownHome`
- `SelectStateChangeTypes.MenuKeyDownEnd`
- `SelectStateChangeTypes.MenuKeyDownEnter`
- `SelectStateChangeTypes.MenuKeyDownSpaceButton`
- `SelectStateChangeTypes.MenuKeyDownCharacter`
- `SelectStateChangeTypes.MenuBlur`
- `SelectStateChangeTypes.MenuMouseLeave`
- `SelectStateChangeTypes.ItemMouseMove`
- `SelectStateChangeTypes.ItemClick`
- `SelectStateChangeTypes.ToggleButtonKeyDownCharacter`
- `SelectStateChangeTypes.ToggleButtonKeyDownArrowDown`
- `SelectStateChangeTypes.ToggleButtonKeyDownArrowUp`
- `SelectStateChangeTypes.ToggleButtonClick`
- `SelectStateChangeTypes.FunctionToggleMenu`
- `SelectStateChangeTypes.FunctionOpenMenu`
- `SelectStateChangeTypes.FunctionCloseMenu`
- `SelectStateChangeTypes.FunctionSetHighlightedIndex`
- `SelectStateChangeTypes.FunctionSelectItem`
- `SelectStateChangeTypes.FunctionSetInputValue`
- `SelectStateChangeTypes.FunctionReset`

### MultiSelect

- `MultipleSelectionStateChangeTypes.SelectedItemClick`
- `MultipleSelectionStateChangeTypes.SelectedItemKeyDownDelete`
- `MultipleSelectionStateChangeTypes.SelectedItemKeyDownBackspace`
- `MultipleSelectionStateChangeTypes.SelectedItemKeyDownNavigationNext`
- `MultipleSelectionStateChangeTypes.SelectedItemKeyDownNavigationPrevious`
- `MultipleSelectionStateChangeTypes.DropdownKeyDownNavigationPrevious`
- `MultipleSelectionStateChangeTypes.DropdownKeyDownBackspace`
- `MultipleSelectionStateChangeTypes.DropdownClick`
- `MultipleSelectionStateChangeTypes.FunctionAddSelectedItem`
- `MultipleSelectionStateChangeTypes.FunctionRemoveSelectedItem`
- `MultipleSelectionStateChangeTypes.FunctionSetSelectedItems`
- `MultipleSelectionStateChangeTypes.FunctionSetActiveIndex`
- `MultipleSelectionStateChangeTypes.FunctionReset`

## Select Props

<SimplePropsTable
  propertyValues={{
    components: {
      type: {
        name: 'SelectComponents',
      },
      required: false,
      description: 'Custom components',
    },
    containerStyle: {
      type: {
        name: 'React.CSSProperties',
      },
      required: false,
      description: 'Style properties for the component container',
    },
    errorMessage: {
      type: {
        name: 'ReactNode',
      },
      required: false,
      description:
        'Content of the error message.  If a value is provided, the component will be styled to show an error state',
      defaultValue: '',
    },
    helperMessage: {
      type: {
        name: 'ReactNode',
      },
      required: false,
      description: 'Content of the helper message',
      defaultValue: '',
    },
    inputStyle: {
      type: {
        name: 'React.CSSProperties',
      },
      required: false,
      description: 'Style properties for the select input',
    },
    isClearable: {
      type: {
        name: 'boolean',
      },
      required: false,
      description:
        'If true, the component include a button for clearing the field',
      defaultValue: 'false',
    },
    disabled: {
      type: {
        name: 'boolean',
      },
      required: false,
      description:
        'If true, item will be disabled; it will appear dimmed and events will not fire',
      defaultValue: 'false',
    },
    isInverse: {
      type: {
        name: 'boolean',
      },
      required: false,
      description:
        'If true, the component will have inverse styling to better appear on a dark background',
      defaultValue: 'false',
    },
    initialHighlightedIndex: {
      type: {
        name: 'number',
      },
      required: false,
      description: 'Index of the initially selected item',
    },
    initialSelectedItem: {
      type: {
        name: 'string',
      },
      required: false,
      description: 'Value of the initially selected item',
    },
    innerRef: {
      type: {
        name: 'React.Ref<HTMLButtonElement>',
      },
      required: false,
      description:
        'Reference to the button element that triggers the select menu opening',
    },
    isLabelVisuallyHidden: {
      type: {
        name: 'boolean',
      },
      required: false,
      description:
        'If true, label text will be hidden visually, but will still be read by assistive technology',
      defaultValue: 'false',
    },
    isMulti: {
      type: {
        name: 'boolean',
      },
      required: false,
      description: 'If true, multiple items may be selected',
      defaultValue: 'false',
    },
    items: {
      type: {
        name: 'array',
      },
      required: false,
      description: 'Selectable options.  Can be an array of strings or objects',
    },
    itemToString: {
      type: {
        name: 'function',
      },
      required: false,
      description:
        'Function that returns the string representation of your item which will be applied as the label when using a custom shape for items',
    },
    labelStyle: {
      type: {
        name: 'React.CSSProperties',
      },
      required: false,
      description: 'Style properties for the label',
    },
    labelText: {
      type: {
        name: 'ReactNode',
      },
      required: true,
      description: 'Text for label',
    },
    messageStyle: {
      type: {
        name: 'React.CSSProperties',
      },
      required: false,
      description: 'Style properties for the helper or error message',
    },
    onHighlightedIndexChange: {
      type: {
        name: 'function',
      },
      required: false,
      description: 'Event that fires when the highlighted index changes',
      defaultValue: '',
    },
    onIsOpenChange: {
      type: {
        name: 'function',
      },
      required: false,
      description: 'Event that fires when the options menu opens or closes',
      defaultValue: '',
    },
    onSelectedItemChange: {
      type: {
        name: 'function',
      },
      required: false,
      description: 'Event that fires hen the selected item changes',
      defaultValue: '',
    },
    onStateChange: {
      type: {
        name: 'function',
      },
      required: false,
      description: 'Event that fires on every internal state changes',
      defaultValue: '',
    },
    testId: {
      type: {
        name: 'string',
      },
      required: false,
      description:
        'Test ID attached to an internal element as `data-testid` for consumer testing',
    },
  }}
/>

export default props => (
  <ScopeableLayout
    {...props}
    components={{
      Select,
      Alert,
      useSelect,
      uuid,
      SelectStateChangeTypes,
      I18nContext,
      defaultI18n,
      Card,
      CardBody,
    }}
  />
);
