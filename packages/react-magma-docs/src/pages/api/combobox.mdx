---
pageTitle: Combobox API
title: Combobox
---

import { ScopeableLayout } from '../../components/layout';
import {
  Combobox,
  ComboboxStateChangeTypes,
  Alert,
  I18nContext,
  defaultI18n,
} from 'react-magma-dom';
import { SimplePropsTable } from '../../components/props-table';
import { Link } from 'gatsby';
import { v4 as uuid } from 'uuid';
import DocsHeading from '../../components/docs-heading';

<DocsHeading to="/design/select/" type="design">
  Combobox
</DocsHeading>

## Basic Usage

A Combobox is similar to a Select component, in that it is used for collecting user provided information from a list of options.
However, a combobox also allows users to type in the field, either to create their own option or to see typeahead suggestions.

For simple Select functionality, please see the <Link to="/api/select">Select component</Link>.

```.jsx
  <>
    <Combobox
      id="comboboxId"
      name="combobox"
      labelText="Combobox"
      defaultItems={[
        { label: 'Red', value: 'red' },
        { label: 'Blue', value: 'blue' },
        { label: 'Green', value: 'green' }
      ]}
      placeholder="Hello"
    />
  </>
```

## Custom Items

By default each component accepts an array of `items` with either a `string` or an `object` with the shape `{item: string; label: string;}`
for each `item`. If you need to pass in a custom shape for your `items` you can pass in an additional prop named `itemToString`
which is a function that returns the string representation of your `item` which will be applied as the label.

<Alert variant="warning">
  <strong>WARNING</strong> Your function must include a <code>null</code> check.
</Alert>

If you are using a custom shape for your `items` in a `typescript` project refer to our example of [using your
custom `type`](/api/combobox#custom_items_typescript).

```.jsx
  () => {
    const [controlledSelectedItem, updateControlledSelectedItem] = React.useState('')
    const [controlledItems, updateControlledItems] = React.useState([
      { id: 0, name: 'red', representation: 'Red', hex: '#FF0000' },
      { id: 1, name: 'blue', representation: 'Blue', hex: '#0000FF' },
      { id: 2, name: 'green', representation: 'Green', hex: '#008000' }
    ])

    function itemToString(item) {
      return item ? `${item.representation}${item.hex ? ` (${item.hex})` : ''}` : ''
    }

    function newItemTransform(item) {
      const { value } = item;

      return {
        id: uuid(),
        name: value,
        representation: value.charAt(0).toUpperCase() + value.slice(1)
      }
    }

    function handleSelectedItemChange(changes) {
      updateControlledSelectedItem(changes.selectedItem)
    }

    function handleItemCreated(newItem) {
      updateControlledSelectedItem(newItem);
      updateControlledItems(oldItems => [...oldItems, newItem]);
    }

    return (
      <>
        <Combobox
          labelText="Combobox With Custom Items"
          defaultItems={[
            { id: 0, name: 'red', representation: 'Red', hex: '#FF0000' },
            { id: 1, name: 'blue', representation: 'Blue', hex: '#0000FF' },
            { id: 2, name: 'green', representation: 'Green', hex: '#008000' }
          ]}
          newItemTransform={newItemTransform}
          itemToString={itemToString}
        />


        { controlledSelectedItem && <>
          <p><strong>Controlled Selected Item</strong></p>
          <pre>{JSON.stringify(controlledSelectedItem, null, 2)}</pre>
        </>}

        <Combobox
          labelText="Controlled Combobox With Custom Items"
          items={controlledItems}
          newItemTransform={newItemTransform}
          itemToString={itemToString}
          onItemCreated={handleItemCreated}
          onSelectedItemChange={handleSelectedItemChange}
          selectedItem={controlledSelectedItem}
        />
      </>
    )
  }
```

## Initial State

Set initial state using the `initialSelectedItem`, `initialSelectedItems`, and `initialHighlightedIndex` props.

<Alert variant="info">
  When using any of the <code class="inverse">initial*</code> props be aware
  that passing in the controlled version of that prop will overwrite the initial
  version.
  <br />
  <br />
  <strong>Ex: </strong>
  <code class="inverse">selectedItem</code> takes precedence over{' '}
  <code class="inverse">initialSelectedItem</code>
</Alert>

```.jsx
  () => {
    return <>
      <Combobox
        id="initialSelectedByItemSelectId"
        name="initialSelectedByItem"
        labelText="Initial Selected By Item"
        defaultItems={[
          { label: 'Red', value: 'red' },
          { label: 'Blue', value: 'blue' },
          { label: 'Green', value: 'green' }
        ]}
        initialSelectedItem={{ label: 'Green', value: 'green' }}
      />

      <Combobox
        id="initialHighlightedIndexSelectId"
        name="initialHighlightedIndex"
        labelText="Initial Highlighted Index"
        defaultItems={[
          { label: 'Red', value: 'red' },
          { label: 'Blue', value: 'blue' },
          { label: 'Green', value: 'green' }
        ]}
        initialHighlightedIndex={1}
      />
    </>
  }
```

## Specific State Changes

You can track changes made to the internal state of the `select` using the following functions: `onHighlightedIndexChange`,
`onIsOpenChange`, `onSelectedItemChange`, and `onStateChange`. Each of these functions will have a `changes` object as a parameter that
includes the changes made to state from each action as well as a `type` that describes the action.

`onStateChange` is best used when using the `select` in a controlled state because it is called on every state change.

```.jsx
  () => {
    const [highlightedIndexChangeCount, updateHighlightedIndexChangeCount] = React.useState(0);
    const [isOpenChangeCount, updateIsOpenChangeCount] = React.useState(0);
    const [selectedItem, updateSelectedItem] = React.useState(undefined);

    function onHighlightedIndexChange(changes) {
      updateHighlightedIndexChangeCount(highlightedIndexChangeCount + 1);
    }

    function onIsOpenChange(changes) {
      updateIsOpenChangeCount(isOpenChangeCount + 1)
    }

    function onSelectedItemChange(changes) {
      updateSelectedItem(changes.selectedItem);
    }

    return <>
      <strong>Selected Item: </strong><pre>{JSON.stringify(selectedItem, null, 2)}</pre>
      <p><strong>Highlighted Index Change Count: </strong>{highlightedIndexChangeCount}</p>
      <p><strong>Is Open Change Count: </strong>{isOpenChangeCount}</p>

      <Combobox
        id="individualStateChangesId"
        name="individualStateChanges"
        labelText="Individual State Changes"
        defaultItems={[
          { label: 'Red', value: 'red' },
          { label: 'Blue', value: 'blue' },
          { label: 'Green', value: 'green' }
        ]}
        onHighlightedIndexChange={onHighlightedIndexChange}
        onIsOpenChange={onIsOpenChange}
        onSelectedItemChange={onSelectedItemChange}
      />
    </>
  }
```

## Generic State Change

<Alert variant="warning">
  Using <code>onStateChange</code> and controlling every piece of{' '}
  <code>state</code> will result in losing most of the functionality that has
  been built in to this component. Only use this feature as a last resort.
</Alert>

`onStateChange` is called when any internal state is changed. Therefore, it is best used when using the
`combobox` in a controlled state.

The `onStateChange` function passes a `changes` object that includes properties that have changed since the
last state change. The `changes` object also includes a `type` property that describes the action taken
to change the state. You can see the full list of the types in the [`stateChangeTypes`](/api/combobox/#state_change_types) section.

```.jsx
  () => {
    const [changes, updateChanges] = React.useState({});
    const [highlightedIndex, updateHighlightedIndex] = React.useState(-1);
    const [isOpen, updateIsOpen] = React.useState(false);
    const [selectedItem, updateSelectedItem] = React.useState({});

    function onStateChange(newChanges) {
      const { type } = newChanges

      updateChanges(newChanges)

      switch(type) {
        case ComboboxStateChangeTypes.ToggleButtonClick:
          updateIsOpen(!isOpen)
          break;
        case ComboboxStateChangeTypes.InputKeyDownArrowDown:
          newChanges.isOpen ? updateIsOpen(newChanges.isOpen) : null
          updateHighlightedIndex(newChanges.highlightedIndex)
          break;
        case ComboboxStateChangeTypes.ItemMouseMove:
        case ComboboxStateChangeTypes.FunctionSetHighlightedIndex:
        case ComboboxStateChangeTypes.InputKeyDownArrowDown:
        case ComboboxStateChangeTypes.InputKeyDownArrowUp:
          updateHighlightedIndex(newChanges.highlightedIndex)
          break;
        case ComboboxStateChangeTypes.InputKeyDownEscape:
        case ComboboxStateChangeTypes.InputBlur:
          updateIsOpen(false)
          updateHighlightedIndex(newChanges.highlightedIndex)
          break;
        case ComboboxStateChangeTypes.ItemClick:
        case ComboboxStateChangeTypes.InputKeyDownEnter:
          updateHighlightedIndex(newChanges.highlightedIndex)
          updateIsOpen(newChanges.isOpen)
          updateSelectedItem(newChanges.selectedItem)
          break;
        default:
          break;
      }
    }

    return (
      <>
        <pre>{JSON.stringify(changes, null, 2)}</pre>
        <strong>Is Open: </strong>{isOpen.toString()}

        <Combobox
          id="stateChangesId"
          name="stateChanges"
          labelText="State Changes"
          defaultItems={[
            { label: 'Red', value: 'red' },
            { label: 'Blue', value: 'blue' },
            { label: 'Green', value: 'green' }
          ]}
          onStateChange={onStateChange}
          highlightedIndex={highlightedIndex}
          isOpen={isOpen}
          selectedItem={selectedItem}
        />
      </>
    )
  }
```

## Controlled Items

If you would like to control your `items` and any updates to them on creation you can pass in a function to the `onItemCreated`
prop. If no `newItemTransform` function is passed in, the created item will be the string value of what was created.

**NOTE**: Your created items will not be added to the `items` list internally. You will have to pass the updated `items` array to the `items` prop.

```.jsx
  () => {
    const defaultItems = [
      { label: 'Red', value: 'red' },
      { label: 'Blue', value: 'blue' },
      { label: 'Green', value: 'green' }
    ];
    const [items, updateItems] = React.useState(defaultItems)

    function newItemTransform(item) {
      return {
        label: item.value,
        value: item.value.toLowerCase()
      }
    }

    function resetItems() {
      updateItems([...defaultItems]);
    }

    function onItemCreated(item) {
      updateItems([...items, item])
    }

    return (
      <>
        <button onClick={resetItems}>Reset Items</button>
        <strong>Items: </strong><pre>{JSON.stringify(items, null, 2)}</pre>
        <Combobox
          id="controlledItemsId"
          name="controlledItems"
          labelText="Controlled Items"
          items={items}
          newItemTransform={newItemTransform}
          onItemCreated={onItemCreated}
        />
      </>
    )
  }
```

## Disabled

```.jsx
  <Combobox
    id="disabledSelectId"
    isDisabled
    name="disabled"
    labelText="Disabled"
    defaultItems={[
      { label: 'Red', value: 'red' },
      { label: 'Blue', value: 'blue' },
      { label: 'Green', value: 'green' }
    ]}
  />
```

## Clearable

The optional `isClearable` prop allows the user to clear the field once a selection has been made.

When using the `isClearable` prop you can choose a default selected item to be set once the `combobox` is cleared
using the `defaultSelectedItem` prop.

```.jsx
  () => {
    return <>
      <Combobox
        id="clearableSelectId"
        name="clearable"
        labelText="Clearable"
        defaultItems={[
          { label: 'Red', value: 'red' },
          { label: 'Blue', value: 'blue' },
          { label: 'Green', value: 'green' }
        ]}
        initialSelectedItem={{ label: 'Green', value: 'green' }}
        isClearable
      />

      <Combobox
        id="clearableWithDefaultsId"
        name="clearableWithDefaults"
        labelText="Clearable With Defaults"
        defaultItems={[
          { label: 'Red', value: 'red' },
          { label: 'Blue', value: 'blue' },
          { label: 'Green', value: 'green' }
        ]}
        isClearable
        defaultSelectedItem={{ label: 'Blue', value: 'blue' }}
      />
    </>
  }
```

## Error Message

If a select has an `errorMessage`, the select will be styled to highlight it's error state and the error message will appear below the field.
If an error message is present, it will replace the helper text. Can be a node or a string.

```.jsx
  () => (
    <>
      <Combobox
        id="errorMessage"
        name="error"
        labelText="Error Message"
        defaultItems={[
          { label: 'Red', value: 'red' },
          { label: 'Blue', value: 'blue' },
          { label: 'Green', value: 'green' }
        ]}
        errorMessage="Please select a color"
      />
    </>
  )
```

## Helper Message

The `helperMessage` appears underneath the select field. It will not appear if an error message is present. Can be a node or a string.

```.jsx
  () => (
    <>
      <Combobox
        id="helperMessage"
        name="helper"
        labelText="Helper Message"
        defaultItems={[
          { label: 'Red', value: 'red' },
          { label: 'Blue', value: 'blue' },
          { label: 'Green', value: 'green' }
        ]}
        helperMessage="Helper text goes here"
      />
    </>
  )
```

## Placeholder

The `placeholder` text of an input can be set using the `placeholder` prop.
Placeholder text should be used to provide supplemental information about the input field. It should not be
relied upon to take the place of the label text.

```.jsx
  () => (
    <>
      <Combobox
        labelText="Placeholder text"
        items={['Red', 'Blue', 'Green']}
        placeholder='Enter or select a color'
      />
    </>
  )
```

## Accessibility

The `getA11yStatusMessage` prop is a passed in function that allows for customization of the screen-reader accessible message whenever the following props
are changed: `items`, `highlightedIndex`, `inputValue` or `isOpen`.

The `getA11ySelectionMessage` prop is a passed in function that allows for customization of the screen-reader accessible message
whenever an item has been selected.

For both the `getA11yStatusMessage` and `getA11ySelectionMessage` functions there is an
[object passed with internal state data](https://github.com/downshift-js/downshift/tree/master/src/hooks/useSelect#geta11yselectionmessage).

```.jsx
  () => {
    return <>
      <Combobox
        id="newA11yStatusMessageId"
        name="newA11yStatusMessage"
        labelText="New Accessibility Status Message"
        defaultItems={[
          { label: 'Red', value: 'red' },
          { label: 'Blue', value: 'blue' },
          { label: 'Green', value: 'green' }
        ]}
        getA11yStatusMessage={({highlightedItem}) => `custom message saying that ${highlightedItem ? highlightedItem.label : 'nothing'} is highlighted`}
        getA11ySelectionMessage={({selectedItem}) => `custom message saying that ${selectedItem ? selectedItem.label : 'nothing'} is now selected`}
      />
    </>
  }
```

## Disable Create Item

```.jsx
  <>
    <Combobox
      disableCreateItem
      id="disableCreateItemId"
      name="disableCreateItem"
      labelText="Disable Create Item"
      defaultItems={[
        { label: 'Red', value: 'red' },
        { label: 'Blue', value: 'blue' },
        { label: 'Green', value: 'green' }
      ]}
    />
  </>
```

## Multi Combobox

```.jsx
() => {
  const [selectedItems, updateSelectedItems] = React.useState([]);

  function handleSelectedItemsChange(changes) {
    updateSelectedItems(changes.selectedItems);
  }

  function handleRemoveSelectedItem(removedItem) {
    updateSelectedItems(
      selectedItems.filter(item => item !== removedItem)
    )
  }

  return (
    <>
      <Combobox
        isMulti
        id="multiComboboxId"
        name="multiCombobox"
        labelText="Multi Combobox"
        initialSelectedItems={[
          { label: 'Red', value: 'red' },
          { label: 'Blue', value: 'blue' }
        ]}
        defaultItems={[
          {label: 'Red', value: 'red'},
          {label: 'Blue', value: 'blue'},
          {label: 'Green', value: 'green'},
          {label: 'Orange', value: 'orange'},
          {label: 'Aqua', value: 'aqua'},
          {label: 'Gold', value: 'gold'},
          {label: 'Perriwinkle', value: 'perriwinkle'},
          {label: 'Lavender', value: 'lavender'},
          {label: 'Marigold', value: 'marigold'},
          {label: 'Yellow', value: 'yellow'},
          {label: 'Purple', value: 'purple'},
          {label: 'Dusty Rose', value: 'dusty_rose'},
          {label: 'Burnt Sienna', value: 'burnt_sienna'}
        ]}
      />

      <Combobox
        isMulti
        id="multiComboboxId2"
        name="multiCombobox2"
        labelText="Multi Combobox"
        initialSelectedItems={[
          {label: 'Red', value: 'red'},
          {label: 'Blue', value: 'blue'},
          {label: 'Green', value: 'green'},
          {label: 'Orange', value: 'orange'},
          {label: 'Aqua', value: 'aqua'},
          {label: 'Gold', value: 'gold'},
          {label: 'Perriwinkle', value: 'perriwinkle'},
          {label: 'Lavender', value: 'lavender'},
          {label: 'Marigold', value: 'marigold'},
          {label: 'Yellow', value: 'yellow'},
          {label: 'Purple', value: 'purple'},
          {label: 'Dusty Rose', value: 'dusty_rose'},
          {label: 'Burnt Sienna', value: 'burnt_sienna'}
        ]}
        defaultItems={[
          {label: 'Red', value: 'red'},
          {label: 'Blue', value: 'blue'},
          {label: 'Green', value: 'green'},
          {label: 'Orange', value: 'orange'},
          {label: 'Aqua', value: 'aqua'},
          {label: 'Gold', value: 'gold'},
          {label: 'Perriwinkle', value: 'perriwinkle'},
          {label: 'Lavender', value: 'lavender'},
          {label: 'Marigold', value: 'marigold'},
          {label: 'Yellow', value: 'yellow'},
          {label: 'Purple', value: 'purple'},
          {label: 'Dusty Rose', value: 'dusty_rose'},
          {label: 'Burnt Sienna', value: 'burnt_sienna'}
        ]}
      />

      <Combobox
        errorMessage="Please correct this error"
        id="multiComboboxControlledId"
        isMulti
        name="multiComboboxControlled"
        labelText="Multi Combobox Controlled"
        defaultItems={[
          { label: 'Red', value: 'red' },
          { label: 'Blue', value: 'blue' },
          { label: 'Green', value: 'green' }
        ]}
        selectedItems={selectedItems}
        onSelectedItemsChange={handleSelectedItemsChange}
        onRemoveSelectedItem={handleRemoveSelectedItem}
      />
    </>
  )
}
```

## Events

```.jsx
  () => {
    const [currentComboboxEvent, updateCurrentComboboxEvent] = React.useState(undefined);

    function handleComboboxInputBlur(event) {
      updateCurrentComboboxEvent('Blur')
    }

    function handleComboboxInputFocus(event) {
      updateCurrentComboboxEvent('Focus')
    }

    function handleComboboxInputKeyPress(event) {
      updateCurrentComboboxEvent('KeyPress')
    }

    return (
      <>
        <p><strong>{currentComboboxEvent || 'No'} event was triggered</strong></p>

        <Combobox
          id="comboboxFocusEventId"
          name="comboboxFocusEvent"
          labelText="Combobox Focus Events"
          defaultItems={[
            { label: 'Red', value: 'red' },
            { label: 'Blue', value: 'blue' },
            { label: 'Green', value: 'green' }
          ]}
          onInputBlur={handleComboboxInputBlur}
          onInputFocus={handleComboboxInputFocus}
          onInputKeyPress={handleComboboxInputKeyPress}
        />
      </>
    )
  }
```

## Async

```.jsx
  () => {
    const [isLoading, updateIsLoading] = React.useState(false);

    function loadItems(inputValue) {
      return new Promise(resolve => resolve([
        { label: 'Yellow', value: 'yellow'},
        { label: 'Pink', value: 'pink' },
        { label: 'Perrywinkle', value: 'perrywinkle'}
      ]))
    }

    function handleInputValueChange(changes, setInputItems) {
      const { inputValue } = changes;

      if (!inputValue) return

      updateIsLoading(true);

      setTimeout(() => {
        updateIsLoading(false);
        loadItems(inputValue).then((items) => {
          setInputItems(items.filter(item =>
            item
              .label
              .toLowerCase()
              .startsWith(inputValue.toLowerCase())
          ))
        })
      }, 1000)
    }

    return <Combobox
      id="asyncId"
      name="async"
      labelText="Async"
      isLoading={isLoading}
      defaultItems={[
        { label: 'Red', value: 'red' },
        { label: 'Blue', value: 'blue' },
        { label: 'Green', value: 'green' }
      ]}
      onInputValueChange={handleInputValueChange}
    />
  }
```

## Inverse

```.jsx
  () => {
    const [selectedItem, updateSelectedItem] = React.useState('');

    function onSelectedItemChange(changes) {
      updateSelectedItem(changes.selectedItem);
    }


    const [selectedItems, updateSelectedItems] = React.useState([]);

    function handleSelectedItemsChange(changes) {
      updateSelectedItems(changes.selectedItems);
    }

    function handleRemoveSelectedItem(removedItem) {
      updateSelectedItems(
        selectedItems.filter(item => item !== removedItem)
      )
    }

    return (<div style={{ background : '#00263E', color: '#ffffff', padding: '10px' }}>

      <Combobox
        id="comboboxInverseId"
        isInverse
        name="comboboxInverse"
        labelText="Combobox"
        defaultItems={[
          { label: 'Red', value: 'red' },
          { label: 'Blue', value: 'blue' },
          { label: 'Green', value: 'green' }
        ]}
      />

      <Combobox
        errorMessage="Please correct this error"
        isMulti
        id="comboboxMultiInverseId"
        isInverse
        labelText="Multi Combobox"
        defaultItems={[
          { label: 'Red', value: 'red' },
          { label: 'Blue', value: 'blue' },
          { label: 'Green', value: 'green' }
        ]}
        initialSelectedItems={[
          { label: 'Red', value: 'red' },
          { label: 'Blue', value: 'blue' },
          { label: 'Green', value: 'green' }
        ]}
        name="comboboxmultiInverse"
      />
    </div>)

  }
```

## Custom Styles

Custom styles can be passed into the Combobox component. The `containerStyle` property will apply to the container.
Additional `labelStyle`, `inputStyle` and `messageStyle` properties are available to style the respective elements.
Please use discretion when adding custom styles.

```.jsx
  () => {
    const [selectedItem, updateSelectedItem] = React.useState('');

    function onSelectedItemChange(changes) {
      updateSelectedItem(changes.selectedItem);
    }

    return <>
      <Combobox
        containerStyle={{ marginBottom: '32px'}}
        helperMessage="Helper message"
        inputStyle={{ border: '2px dotted green', width: '200px'}}
        items={['Red', 'Blue', 'Green']}
        labelStyle={{ fontStyle: 'italic' }}
        labelText="Basic with Custom Styles"
        messageStyle={{ border: '1px solid blue' }}
        selectedItem={selectedItem}
        onSelectedItemChange={onSelectedItemChange}
      />

      <Combobox
        containerStyle={{ marginBottom: '32px'}}
        helperMessage="Helper message"
        inputStyle={{ border: '2px dotted green', width: '200px'}}
        isMulti
        items={['Red', 'Blue', 'Green']}
        labelStyle={{ fontStyle: 'italic' }}
        labelText="Multi with Custom Styles"
        messageStyle={{ border: '1px solid blue' }}
        selectedItem={selectedItem}
        onSelectedItemChange={onSelectedItemChange}
      />
    </>
  }
```

## Custom Components

```.jsx
  () => {
    const [isLoading, updateIsLoading] = React.useState(false);

    function loadItems(inputValue) {
      return new Promise(resolve => resolve([
        { label: 'Yellow', value: 'yellow'},
        { label: 'Pink', value: 'pink' },
        { label: 'Perrywinkle', value: 'perrywinkle'}
      ]))
    }

    function handleInputValueChange(changes, setInputItems) {
      const { inputValue } = changes;

      if (!inputValue) return

      updateIsLoading(true);

      setTimeout(() => {
        updateIsLoading(false);
        loadItems(inputValue).then((items) => {
          setInputItems(items.filter(item =>
            item
              .label
              .toLowerCase()
              .startsWith(inputValue.toLowerCase())
          ))
        })
      }, 1000)
    }

    return (<>
      <Combobox
        id="customComponentsId"
        name="customComponents"
        labelText="Custom Components"
        isLoading={isLoading}
        defaultItems={[
          { label: 'Red', value: 'red' },
          { label: 'Blue', value: 'blue' },
          { label: 'Green', value: 'green' }
        ]}
        isClearable
        onInputValueChange={handleInputValueChange}
        components={{
          ClearIndicator: (props) => <button onClick={props.onClick}>Clear</button>,
          DropdownIndicator: React.forwardRef((props, ref) => <button ref={ref} onClick={props.onClick}>Dropdown</button>),
          LoadingIndicator: (props) => <>Loading</>
        }}
      />
    </>)
  }

```

## Internationalization

Some of the internationalization overrides use placeholders to insert selected values in to the message.
Placeholders are specific keywords surrounded by curly braces.

- `{labelText}` will be replaced with the comboboxes `labelText`.
- `{selectedItem}` will be replaced by the current `itemToString` representation of the `selectedItem` of the `combobox`.
- `{inputValue}` will be replaced by the current `inputValue` of the `combobox` input.

<Link to="/api/internationalization">
  Full example of internationalization override options
</Link>

```.jsx
  () => {
    return (<I18nContext.Provider value={{
      ...defaultI18n,
      combobox: {
        clearIndicatorAriaLabel: 'click to reset selection for {labelText}. {selectedItem} is currently selected',
        createLabel: 'Custom Create "{inputValue}"'
      },
      multiCombobox: {
        selectedItemButtonAriaLabel: 'click to reset the selected item {selectedItem}'
      }
    }}>
      <Combobox
        labelText="Internationalization"
        defaultItems={[
          { label: 'Red', value: 'red' },
          { label: 'Blue', value: 'blue' },
          { label: 'Green', value: 'green' }
        ]}
        isClearable
        initialSelectedItem={{ label: 'Red', value: 'red' }}
      />

      <Combobox
        labelText="Multi Internationalization"
        isMulti
        defaultItems={[
          { label: 'Red', value: 'red' },
          { label: 'Blue', value: 'blue' },
          { label: 'Green', value: 'green' }
        ]}
        initialSelectedItems={[{ label: 'Red', value: 'red' }]}
      />
    </I18nContext.Provider>)
  }
```

## Custom Items Typescript

When using a custom shape for your `items` in a `typescript` project you will need to provide the `Combobox`
element with the shape of the `items` you are passing in.

```
  interface CustomComboboxItem {
    id: number;
    actual: string;
    representation: string;
    hex?: string;
  }

  () => {
    const customItems: CustomComboboxItem[] = [
      {
        id: 1,
        actual: "red",
        representation: "Red",
        hex: "#FF0000",
      },
      {
        id: 2,
        actual: "blue",
        representation: "Blue",
        hex: "#0000FF",
      },
      {
        id: 3,
        actual: "green",
        representation: "Green",
        hex: "#008000",
      },
    ];

    function itemToString(item: CustomComboboxItem) {
      return item ? `${item.representation} (${item.hex})` : ''
    }

    function newItemTransform(item: { label: string, value: string }): CustomComboboxItem {
      const { value } = item;

      return {
        id: uuid(),
        name: value,
        representation: value.charAt(0).toUpperCase() + value.slice(1)
      }
    }

    return <>
      <Combobox<CustomComboboxItem>
        id="customItemToStringTypescriptId"
        labelText="Cust Items with Typescript"
        defaultItems={customItems}
        itemToString={itemToString}
        newItemTransform={newItemTransform}
      />
    </>
  }
```

## State Change Types

The `type` property in the `changes` object that is returned from the `onStateChange` function
corresponds to a `stateChangeTypes` property. The list of all the possible types for a `combobox` or a
`multi-combobox` are listed below.

<Alert variant="info">
  In the development environment these types equate to strings
  <br />
  (eg:{' '}
  <code class="inverse">
    ComboboxStateChangeTypes.InputKeyDownArrowDown =
    '__input_keydown_arrow_down__'
  </code>
  ). However, in the production environment the types equate to numbers
  <br />
  (eg: <code class="inverse">
    ComboboxStateChangeTypes.InputKeyDownArrowDown = 0
  </code>
  ).
</Alert>

### Combobox

- `ComboboxStateChangeTypes.InputKeyDownArrowDown`
- `ComboboxStateChangeTypes.InputKeyDownArrowUp`
- `ComboboxStateChangeTypes.InputKeyDownEscape`
- `ComboboxStateChangeTypes.InputKeyDownHome`
- `ComboboxStateChangeTypes.InputKeyDownEnd`
- `ComboboxStateChangeTypes.InputKeyDownEnter`
- `ComboboxStateChangeTypes.InputChange`
- `ComboboxStateChangeTypes.InputBlur`
- `ComboboxStateChangeTypes.MenuMouseLeave`
- `ComboboxStateChangeTypes.ItemMouseMove`
- `ComboboxStateChangeTypes.ItemClick`
- `ComboboxStateChangeTypes.ToggleButtonClick`
- `ComboboxStateChangeTypes.FunctionToggleMenu`
- `ComboboxStateChangeTypes.FunctionOpenMenu`
- `ComboboxStateChangeTypes.FunctionCloseMenu`
- `ComboboxStateChangeTypes.FunctionSetHighlightedIndex`
- `ComboboxStateChangeTypes.FunctionSelectItem`
- `ComboboxStateChangeTypes.FunctionSetInputValue`
- `ComboboxStateChangeTypes.FunctionReset`

### MultiCombobox

- `MultipleSelectionStateChangeTypes.SelectedItemClick`
- `MultipleSelectionStateChangeTypes.SelectedItemKeyDownDelete`
- `MultipleSelectionStateChangeTypes.SelectedItemKeyDownBackspace`
- `MultipleSelectionStateChangeTypes.SelectedItemKeyDownNavigationNext`
- `MultipleSelectionStateChangeTypes.SelectedItemKeyDownNavigationPrevious`
- `MultipleSelectionStateChangeTypes.DropdownKeyDownNavigationPrevious`
- `MultipleSelectionStateChangeTypes.DropdownKeyDownBackspace`
- `MultipleSelectionStateChangeTypes.DropdownClick`
- `MultipleSelectionStateChangeTypes.FunctionAddSelectedItem`
- `MultipleSelectionStateChangeTypes.FunctionRemoveSelectedItem`
- `MultipleSelectionStateChangeTypes.FunctionSetSelectedItems`
- `MultipleSelectionStateChangeTypes.FunctionSetActiveIndex`
- `MultipleSelectionStateChangeTypes.FunctionReset`

## Combobox Props

<SimplePropsTable
  propertyValues={{
    components: {
      type: {
        name: 'DownshiftComponents',
      },
      required: false,
      description: 'Custom components',
    },
    containerStyle: {
      type: {
        name: 'React.CSSProperties',
      },
      required: false,
      description: 'Style properties for the component container',
    },
    errorMessage: {
      type: {
        name: 'ReactNode',
      },
      required: false,
      description:
        'Content of the error message.  If a value is provided, the component will be styled to show an error state',
      defaultValue: '',
    },
    disableCreateItem: {
      type: {
        name: 'boolean',
      },
      required: false,
      description:
        'If true, the new items cannot be created by typing in the text field',
      defaultValue: 'false',
    },
    helperMessage: {
      type: {
        name: 'ReactNode',
      },
      required: false,
      description: 'Content of the helper message',
      defaultValue: '',
    },
    initialSelectedItem: {
      type: {
        name: 'string',
      },
      required: false,
      description: 'Value of the initially selected item',
    },
    inputStyle: {
      type: {
        name: 'React.CSSProperties',
      },
      required: false,
      description: 'Style properties for the select input',
    },
    isLabelVisuallyHidden: {
      type: {
        name: 'boolean',
      },
      required: false,
      description:
        'If true, label text will be hidden visually, but will still be read by assistive technology',
      defaultValue: 'false',
    },
    isMulti: {
      type: {
        name: 'boolean',
      },
      required: false,
      description: 'If true, multiple items may be selected',
      defaultValue: 'false',
    },
    isClearable: {
      type: {
        name: 'boolean',
      },
      required: false,
      description:
        'If true, the component include a button for clearing the field',
      defaultValue: 'false',
    },
    isDisabled: {
      type: {
        name: 'boolean',
      },
      required: false,
      description:
        'If true, item will be disabled; it will appear dimmed and events will not fire',
      defaultValue: 'false',
    },
    isInverse: {
      type: {
        name: 'boolean',
      },
      required: false,
      description:
        'If true, the component will have inverse styling to better appear on a dark background',
      defaultValue: 'false',
    },
    isMulti: {
      type: {
        name: 'boolean',
      },
      required: false,
      description: 'If true, multiple items may be selected',
      defaultValue: 'false',
    },
    items: {
      type: {
        name: 'array',
      },
      required: false,
      description:
        'Selectable options.  Can be an array of strings or objects.',
    },
    itemToString: {
      type: {
        name: 'function',
      },
      required: false,
      description:
        'Function that returns the string representation of your item which will be applied as the label when using a custom shape for items',
    },
    labelStyle: {
      type: {
        name: 'React.CSSProperties',
      },
      required: false,
      description: 'Style properties for the label',
    },
    labelText: {
      type: {
        name: 'ReactNode',
      },
      required: true,
      description: 'Text for label',
    },
    messageStyle: {
      type: {
        name: 'React.CSSProperties',
      },
      required: false,
      description: 'Style properties for the helper or error message',
    },
    onHighlightedIndexChange: {
      type: {
        name: 'function',
      },
      required: false,
      description: 'Event that fires when the highlighted index changes',
      defaultValue: '',
    },
    onIsOpenChange: {
      type: {
        name: 'function',
      },
      required: false,
      description: 'Event that fires when the options menu opens or closes',
      defaultValue: '',
    },
    onSelectedItemChange: {
      type: {
        name: 'function',
      },
      required: false,
      description: 'Event that fires hen the selected item changes',
      defaultValue: '',
    },
    onStateChange: {
      type: {
        name: 'function',
      },
      required: false,
      description: 'Event that fires on every internal state changes',
      defaultValue: '',
    },
    placeholder: {
      type: {
        name: 'string',
      },
      required: false,
      description: 'Text for input placeholder',
      defaultValue: '',
    },
    testId: {
      type: {
        name: 'string',
      },
      required: false,
      description:
        'Test ID attached to an internal element as `data-testid` for consumer testing',
    },
  }}
/>

export default props => (
  <ScopeableLayout
    {...props}
    components={{
      Combobox,
      Alert,
      uuid,
      ComboboxStateChangeTypes,
      I18nContext,
      defaultI18n,
    }}
  />
);
