---
title: 'Combobox'
---

import { ScopeableLayout } from '../../components/layout'
import { Combobox } from 'react-magma-dom'
import { SimplePropsTable } from '../../components/props-table'
import { Link } from 'gatsby'
import { v4 as uuid } from 'uuid'

# Combobox

## Basic Usage

A Combobox is similar to a Select component, in that it is used for collecting user provided information from a list of options.
However, a combobox also allows users to type in the field, either to create their own option or to see typeahead suggestions.

For simple Select functionality, please see the <Link to="/api/downshift-select">Select component</Link>.

```.jsx
  <>
    <Combobox
      id="comboboxId"
      name="combobox"
      labelText="Combobox"
      defaultItems={['Red', 'Blue', 'Green']}
      placeholder="Hello"
    />
  </>
```

## Custom Items

By default each component accepts an array of `items` with either a `string` or an `object` with the shape `{item: string; label: string;}`
for each `item`. If you need to pass in a custom shape for your `items` you can pass in an additional prop named `itemToString`
which is a function that returns the string representation of your `item` which will be applied as the label.

**WARNING** Your function must include a `null` check.

```.jsx
  () => {
    const [controlledSelectedItem, updateControlledSelectedItem] = React.useState('')
    const [controlledItems, updateControlledItems] = React.useState([
      { id: 0, name: 'red', representation: 'Red' },
      { id: 1, name: 'blue', representation: 'Blue' },
      { id: 2, name: 'green', representation: 'Green' }
    ])

    function itemToString(item) {
      return item ? item.representation : ''
    }

    function newItemTransform(item) {
      const { value } = item;

      return {
        id: uuid(),
        name: value,
        representation: value.charAt(0).toUpperCase() + value.slice(1)
      }
    }

    function handleSelectedItemChange(changes) {
      updateControlledSelectedItem(changes.selectedItem)
    }

    function handleItemCreated(newItem) {
      updateControlledSelectedItem(newItem);
      updateControlledItems(oldItems => [...oldItems, newItem]);
    }

    return (
      <>
        <Combobox
          labelText="Combobox With Custom Items"
          defaultItems={[
            { id: 0, name: 'red', representation: 'Red' },
            { id: 1, name: 'blue', representation: 'Blue' },
            { id: 2, name: 'green', representation: 'Green' }
          ]}
          newItemTransform={newItemTransform}
          itemToString={itemToString}
        />


        { controlledSelectedItem && <>
          <p><strong>Controlled Selected Item</strong></p>
          <pre>{JSON.stringify(controlledSelectedItem, null, 2)}</pre>
        </>}

        <Combobox
          labelText="Controlled Combobox With Custom Items"
          items={controlledItems}
          newItemTransform={newItemTransform}
          itemToString={itemToString}
          onItemCreated={handleItemCreated}
          onSelectedItemChange={handleSelectedItemChange}
          selectedItem={controlledSelectedItem}
        />
      </>
    )
  }
```

## Inital State

Set inital state using the `initalSelectedItem` and `initialHighlightedIndex` props.

```.jsx
  () => {
    return <>
      <Combobox
        id="initialSelectedByItemSelectId"
        name="initialSelectedByItem"
        labelText="Initial Selected By Item"
        items={['Red', 'Blue', 'Green']}
        initialSelectedItem={'Green'}
      />

      <Combobox
        id="initialSelectedByIndexSelectId"
        name="initialSelectedByIndex"
        labelText="Initial Selected By Index"
        items={['Red', 'Blue', 'Green']}
        initialHighlightedIndex={1}
      />
    </>
  }
```

## State Changes

You can track changes made to the internal state of the `select` using the following functions: `onHighlightedIndexChange`,
`onIsOpenChange`, `onSelectedItemChange`, and `onStateChange`. Each of these functions will have a `changes` object as a parameter that
includes the changes made to state from each action as well as a `type` that describes the action.

`onStateChange` is best used when using the `select` in a controlled state because it is called on every state change.

```.jsx
  () => {
    const [highlightedIndexChangeCount, updateHighlightedIndexChangeCount] = React.useState(0);
    const [isOpenChangeCount, updateIsOpenChangeCount] = React.useState(0);
    const [selectedItem, updateSelectedItem] = React.useState(undefined);
    const [changes, updateChanges] = React.useState({});

    function onHighlightedIndexChange(changes) {
      updateHighlightedIndexChangeCount(highlightedIndexChangeCount + 1);
    }

    function onIsOpenChange(changes) {
      updateIsOpenChangeCount(isOpenChangeCount + 1)
    }

    function onSelectedItemChange(changes) {
      updateSelectedItem(changes.selectedItem);
    }

    function onStateChange(newChanges) {
      updateChanges(newChanges)
    }

    return <>
      <p><strong>Selected Item: </strong>{selectedItem}</p>
      <p><strong>Highlighted Index Change Count: </strong>{highlightedIndexChangeCount}</p>
      <p><strong>Is Open Change Count: </strong>{isOpenChangeCount}</p>

      <Combobox
        id="stateChangesId"
        name="stateChanges"
        labelText="State Changes"
        items={['Red', 'Blue', 'Green']}
        onHighlightedIndexChange={onHighlightedIndexChange}
        onIsOpenChange={onIsOpenChange}
        onSelectedItemChange={onSelectedItemChange}
      />

      <pre>{JSON.stringify(changes, null, 2)}</pre>

      <Combobox
        id="stateChangesId"
        name="stateChanges"
        labelText="State Changes"
        items={['Red', 'Blue', 'Green']}
        onStateChange={onStateChange}
      />
    </>
  }
```

## Controlled Items

If you would like to control your `items` and any updates to them on creation you can pass in a function to the `onItemCreated`
prop. If no `newItemTransform` function is passed in, the created item will be the string value of what was created.

**NOTE**: Your created items will not be added to the `items` list internally. You will have to pass the updated `items` array to the `items` prop.

```.jsx
  () => {
    const defaultItems = ['Red', 'Blue', 'Green'];
    const [items, updateItems] = React.useState(defaultItems)

    function newItemTransform(item) {
      return item.value
    }

    function resetItems() {
      updateItems([...defaultItems]);
    }

    function onItemCreated(item) {
      updateItems([...items, item])
    }

    return (
      <>
        <button onClick={resetItems}>Reset Items</button>
        <strong>Items: </strong><pre>{items.toString()}</pre>
        <Combobox
          id="controlledItemsId"
          name="controlledItems"
          labelText="Controlled Items"
          items={items}
          newItemTransform={newItemTransform}
          onItemCreated={onItemCreated}
        />
      </>
    )
  }
```

## Disabled

```.jsx
  <Combobox
    id="disabledSelectId"
    isDisabled
    name="disabled"
    labelText="Disabled"
    items={['Red', 'Blue', 'Green']}
  />
```

## Clearable

The optional `isClearable` prop allows the user to clear the field once a selection has been made.

When using the `isClearable` prop you can set default values to be set once the `select` is cleared.
These props are `defaultSelectedItem`, and `defaultHighlightedIndex`.

```.jsx
  () => {
    return <>
      <Combobox
        id="clearableSelectId"
        name="clearable"
        labelText="Clearable"
        items={['Red', 'Blue', 'Green']}
        initialSelectedItem={'Green'}
        isClearable
      />

      <Combobox
        id="clearableWithDefaultsId"
        name="clearableWithDefaults"
        labelText="Clearable With Defaults"
        items={['Red', 'Blue', 'Green']}
        isClearable
        defaultSelectedItem={'Blue'}
      />
    </>
  }
```

## Error Message

If a select has an `errorMessage`, the select will be styled to highlight it's error state and the error message will appear below the field.
If an error message is present, it will replace the helper text. Can be a node or a string.

```.jsx
  () => (
    <>
      <Combobox
        id="errorMessage"
        name="error"
        labelText="Error Message"
        items={['Red', 'Blue', 'Green']}
        errorMessage="Please select a color"
      />
    </>
  )
```

## Helper Message

The `helperMessage` appears underneath the select field. It will not appear if an error message is present. Can be a node or a string.

```.jsx
  () => (
    <>
      <Combobox
        id="helperMessage"
        name="helper"
        labelText="Helper Message"
        items={['Red', 'Blue', 'Green']}
        helperMessage="Helper text goes here"
      />
    </>
  )
```

## A11y

The `getA11yStatusMessage` prop is a passed in function that allows for cusomization of the a11y message whenever the following props
are changes: `items`, `highlightedIndex`, `inputValue` or `isOpen`.

The `getA11ySelectionMessage` prop is a passed in function that allows for customization of the a11y message
whenever an item has been selected.

For both the `getA11yStatusMessage` and `getA11ySelectionMessage` functions there is an
[object passed with internal state data](https://github.com/downshift-js/downshift/tree/master/src/hooks/useSelect#geta11yselectionmessage).

```.jsx
  () => {
    return <>
      <Combobox
        id="newA11yStatusMessageId"
        name="newA11yStatusMessage"
        labelText="New A11y Status Message"
        items={['Red', 'Blue', 'Green']}
        getA11yStatusMessage={({highlightedItem}) => `custom message saying that ${highlightedItem} is highlighted`}
        getA11ySelectionMessage={({selectedItem}) => `custom message saying that ${selectedItem} is now selected`}
      />
    </>
  }
```

## Disable Create Item

```.jsx
  <>
    <Combobox
      disableCreateItem
      id="disableCreateItemId"
      name="disableCreateItem"
      labelText="Disable Create Item"
      defaultItems={['Red', 'Blue', 'Green']}
    />
  </>
```

## Multi Combobox

```.jsx
() => {
  const [selectedItems, updateSelectedItems] = React.useState([]);

  function handleSelectedItemsChange(changes) {
    updateSelectedItems(changes.selectedItems);
  }

  function handleRemoveSelectedItem(removedItem) {
    updateSelectedItems(
      selectedItems.filter(item => item !== removedItem)
    )
  }

  return (
    <>
      <Combobox
        isMulti
        id="multiComboboxId"
        name="multiCombobox"
        labelText="Multi Combobox"
        initialSelectedItems={['Red', 'Blue']}
        defaultItems={['Red', 'Blue', 'Green', 'Orange', 'Aqua', 'Gold', 'Perriwinkle', 'Lavender', 'Marigold', 'Yellow', 'Purple', 'Dusty Rose', 'Burnt Sienna']}
      />

      <Combobox
        isMulti
        id="multiComboboxId2"
        name="multiCombobox2"
        labelText="Multi Combobox"
        initialSelectedItems={['Red', 'Blue', 'Green', 'Orange', 'Aqua', 'Gold', 'Perriwinkle', 'Lavender', 'Burnt Sienna']}
        defaultItems={['Red', 'Blue', 'Green', 'Orange', 'Aqua', 'Gold', 'Perriwinkle', 'Lavender', 'Marigold', 'Yellow', 'Purple', 'Dusty Rose', 'Burnt Sienna']}
      />

      <Combobox
        errorMessage="Please correct this error"
        id="multiComboboxControlledId"
        isMulti
        name="multiComboboxControlled"
        labelText="Multi Combobox Controlled"
        defaultItems={['Red', 'Blue', 'Green']}
        selectedItems={selectedItems}
        onSelectedItemsChange={handleSelectedItemsChange}
        onRemoveSelectedItem={handleRemoveSelectedItem}
      />
    </>
  )
}
```

## Events

```.jsx
  () => {
    const [currentComboboxEvent, updateCurrentComboboxEvent] = React.useState(undefined);

    function handleComboboxInputBlur(event) {
      updateCurrentComboboxEvent('Blur')
    }

    function handleComboboxInputFocus(event) {
      updateCurrentComboboxEvent('Focus')
    }

    function handleComboboxInputKeyPress(event) {
      updateCurrentComboboxEvent('KeyPress')
    }

    return (
      <>
        <p><strong>{currentComboboxEvent || 'No'} event was triggered</strong></p>

        <Combobox
          id="comboboxFocusEventId"
          name="comboboxFocusEvent"
          labelText="Combobox Focus Events"
          defaultItems={['Red', 'Blue', 'Green']}
          onInputBlur={handleComboboxInputBlur}
          onInputFocus={handleComboboxInputFocus}
          onInputKeyPress={handleComboboxInputKeyPress}
        />
      </>
    )
  }
```

## Async

```.jsx
  () => {
    const [isLoading, updateIsLoading] = React.useState(false);

    function loadItems(inputValue) {
      return new Promise(resolve => resolve(['Yellow', 'Pink', 'Perrywinkle']))
    }

    function handleInputValueChange(changes, setInputItems) {
      const { inputValue } = changes;

      updateIsLoading(true);

      setTimeout(() => {
        updateIsLoading(false);
        loadItems(inputValue).then((items) => {
          setInputItems(items.filter(item =>
            item
              .toLowerCase()
              .startsWith(inputValue.toLowerCase())
          ))
        })
      }, 1000)
    }

    return <Combobox
      id="asyncId"
      name="async"
      labelText="Async"
      isLoading={isLoading}
      defaultItems={['Red', 'Blue', 'Green']}
      onInputValueChange={handleInputValueChange}
    />
  }
```

## Inverse

```.jsx
  () => {
    const [selectedItem, updateSelectedItem] = React.useState('');

    function onSelectedItemChange(changes) {
      updateSelectedItem(changes.selectedItem);
    }


    const [selectedItems, updateSelectedItems] = React.useState([]);

    function handleSelectedItemsChange(changes) {
      updateSelectedItems(changes.selectedItems);
    }

    function handleRemoveSelectedItem(removedItem) {
      updateSelectedItems(
        selectedItems.filter(item => item !== removedItem)
      )
    }

    return (<div style={{ background : '#00263E', color: '#ffffff', padding: '10px' }}>

      <Combobox
        id="comboboxInverseId"
        isInverse
        name="combobox"
        labelText="Combobox"
        defaultItems={['Red', 'Blue', 'Green']}
      />

      <Combobox
        errorMessage="Please correct this error"
        isMulti
        id="comboboxMultiInverseId"
        isInverse
        labelText="Multi Combobox"
        defaultItems={['Red', 'Blue', 'Green']}
        initialSelectedItems={['Red', 'Green', 'Blue']}
        name="comboboxmulti"
      />
    </div>)

  }
```

## Custom Components

```.jsx
  () => {
    const [isLoading, updateIsLoading] = React.useState(false);

    function loadItems(inputValue) {
      return new Promise(resolve => resolve(['Yellow', 'Pink', 'Perrywinkle']))
    }

    function handleInputValueChange(changes, setInputItems) {
      const { inputValue } = changes;

      updateIsLoading(true);

      setTimeout(() => {
        updateIsLoading(false);
        loadItems(inputValue).then((items) => {
          setInputItems(items.filter(item =>
            item
              .toLowerCase()
              .startsWith(inputValue.toLowerCase())
          ))
        })
      }, 1000)
    }

    return (<>
      <Combobox
        id="customComponentsId"
        name="customComponents"
        labelText="Custom Components"
        isLoading={isLoading}
        defaultItems={['Red', 'Blue', 'Green']}
        isClearable
        onInputValueChange={handleInputValueChange}
        components={{
          ClearIndicator: (props) => <button onClick={props.onClick}>Clear</button>,
          DropdownIndicator: React.forwardRef((props, ref) => <button ref={ref} onClick={props.onClick}>Dropdown</button>),
          LoadingIndicator: (props) => <>Loading</>
        }}
      />
    </>)
  }

```

## Combobox Props

<SimplePropsTable
  propertyValues={{
    errorMessage: {
      type: {
        name: 'ReactNode',
      },
      required: false,
      description:
        'Content of the errror message.  If a value is provided, the error message will be styled as an error state.',
      defaultValue: '',
    },
    helperMessage: {
      type: {
        name: 'ReactNode',
      },
      required: false,
      description: 'Content of the helper message.',
      defaultValue: '',
    },
    isInverse: {
      type: {
        name: 'boolean',
      },
      required: false,
      description:
        'If true, the component will have inverse styling to better appear on a dark background',
      defaultValue: 'false',
    },
    labelText: {
      type: {
        name: 'ReactNode',
      },
      required: true,
      description: 'Text for label',
    },
    inverse: {
      type: {
        name: 'boolean',
      },
      required: false,
      description:
        'If true, the component will have inverse styling to better appear on a dark background',
      defaultValue: 'false',
    },
    messageStyle: {
      type: {
        name: 'React.CSSProperties',
      },
      required: false,
      description: 'Style properties for the helper or error message',
    },
    testId: {
      type: {
        name: 'string',
      },
      required: false,
      description:
        'Test ID attached to an internal element as `data-testid` for consumer testing',
    },
  }}
/>

export default props => (
  <ScopeableLayout
    {...props}
    components={{
      Combobox,
      uuid,
    }}
  />
)
